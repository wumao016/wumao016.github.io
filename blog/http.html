<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>HTTP | 前端日志</title>
    <meta name="generator" content="VuePress 1.9.5">
    
    <meta name="description" content="欢迎访问我的前端日志">
    
    <link rel="preload" href="/assets/css/0.styles.e1700646.css" as="style"><link rel="preload" href="/assets/js/app.a0896f0e.js" as="script"><link rel="preload" href="/assets/js/2.88eb2c00.js" as="script"><link rel="preload" href="/assets/js/17.be1e4a31.js" as="script"><link rel="prefetch" href="/assets/js/10.d30f3d8f.js"><link rel="prefetch" href="/assets/js/11.e2b957ff.js"><link rel="prefetch" href="/assets/js/12.2da1d6bb.js"><link rel="prefetch" href="/assets/js/13.8ce2c088.js"><link rel="prefetch" href="/assets/js/14.16109f84.js"><link rel="prefetch" href="/assets/js/15.93448cfb.js"><link rel="prefetch" href="/assets/js/16.6f18825f.js"><link rel="prefetch" href="/assets/js/18.e635c0f4.js"><link rel="prefetch" href="/assets/js/19.be17ff30.js"><link rel="prefetch" href="/assets/js/20.d142b0c9.js"><link rel="prefetch" href="/assets/js/21.e40d6d09.js"><link rel="prefetch" href="/assets/js/22.071940ae.js"><link rel="prefetch" href="/assets/js/23.99088ae7.js"><link rel="prefetch" href="/assets/js/24.670dab57.js"><link rel="prefetch" href="/assets/js/25.85694927.js"><link rel="prefetch" href="/assets/js/26.461dcdb2.js"><link rel="prefetch" href="/assets/js/27.878ab7f9.js"><link rel="prefetch" href="/assets/js/28.1fcc3f4d.js"><link rel="prefetch" href="/assets/js/29.86923448.js"><link rel="prefetch" href="/assets/js/3.037aac60.js"><link rel="prefetch" href="/assets/js/30.724a5ac7.js"><link rel="prefetch" href="/assets/js/31.ac601726.js"><link rel="prefetch" href="/assets/js/32.765bf8d3.js"><link rel="prefetch" href="/assets/js/33.509ffbda.js"><link rel="prefetch" href="/assets/js/34.5aa96cf1.js"><link rel="prefetch" href="/assets/js/35.f1909c5d.js"><link rel="prefetch" href="/assets/js/36.36538350.js"><link rel="prefetch" href="/assets/js/37.b9375bb3.js"><link rel="prefetch" href="/assets/js/38.193abee5.js"><link rel="prefetch" href="/assets/js/39.b584d1b5.js"><link rel="prefetch" href="/assets/js/4.a0809240.js"><link rel="prefetch" href="/assets/js/40.17832949.js"><link rel="prefetch" href="/assets/js/41.cde349a4.js"><link rel="prefetch" href="/assets/js/42.67b16448.js"><link rel="prefetch" href="/assets/js/43.1b5d99f6.js"><link rel="prefetch" href="/assets/js/44.9ecb1424.js"><link rel="prefetch" href="/assets/js/5.77c6fbd3.js"><link rel="prefetch" href="/assets/js/6.609d5ed0.js"><link rel="prefetch" href="/assets/js/7.9131668e.js"><link rel="prefetch" href="/assets/js/8.f1d4a37a.js"><link rel="prefetch" href="/assets/js/9.8be87860.js">
    <link rel="stylesheet" href="/assets/css/0.styles.e1700646.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">前端日志</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/blog/" class="nav-link router-link-active">
  博客
</a></div><div class="nav-item"><a href="/combat/" class="nav-link">
  实战
</a></div><div class="nav-item"><a href="/book/" class="nav-link">
  阅读
</a></div><div class="nav-item"><a href="https://github.com/wumao016" target="_blank" rel="noopener noreferrer" class="nav-link external">
  github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/blog/" class="nav-link router-link-active">
  博客
</a></div><div class="nav-item"><a href="/combat/" class="nav-link">
  实战
</a></div><div class="nav-item"><a href="/book/" class="nav-link">
  阅读
</a></div><div class="nav-item"><a href="https://github.com/wumao016" target="_blank" rel="noopener noreferrer" class="nav-link external">
  github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>DevOps</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/php.html" class="sidebar-link">工具的安装</a></li><li><a href="/blog/php1.html" class="sidebar-link">PHP</a></li><li><a href="/blog/node.html" class="sidebar-link">Node.js</a></li><li><a href="/blog/webpack.html" class="sidebar-link">Webpack 使用</a></li><li><a href="/blog/gulp.html" class="sidebar-link">构建工具和脚手架</a></li><li><a href="/blog/optimization.html" class="sidebar-link">性能优化</a></li><li><a href="/blog/nginx.html" class="sidebar-link">Nginx</a></li><li><a href="/blog/engineering.html" class="sidebar-link">前端工程化</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>Framework</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/express.html" class="sidebar-link">Express</a></li><li><a href="/blog/koa1.html" class="sidebar-link">Koa</a></li><li><a href="/blog/vue.html" class="sidebar-link">VUE 源码</a></li><li><a href="/blog/react.html" class="sidebar-link">React 使用</a></li><li><a href="/blog/uniapp.html" class="sidebar-link">Uni-app使用</a></li><li><a href="/blog/ts.html" class="sidebar-link">TS 使用</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>CSS</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/css-3d.html" class="sidebar-link">CSS使用</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>JS</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/es5.html" class="sidebar-link">ES5.1</a></li><li><a href="/blog/es6.html" class="sidebar-link">ES6</a></li><li><a href="/blog/javascript-QA.html" class="sidebar-link">Javascript与QA工程师</a></li><li><a href="/blog/js.html" class="sidebar-link">JavaScript 精粹</a></li><li><a href="/blog/js-function.html" class="sidebar-link">函数式编程</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>其它</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/html.html" class="sidebar-link">同源和跨域</a></li><li><a href="/blog/http.html" aria-current="page" class="active sidebar-link">HTTP</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/http.html#http-协议详解" class="sidebar-link">HTTP 协议详解</a></li><li class="sidebar-sub-header"><a href="/blog/http.html#cookies与session" class="sidebar-link">Cookies与Session</a></li><li class="sidebar-sub-header"><a href="/blog/http.html#http缓存机制" class="sidebar-link">HTTP缓存机制</a></li><li class="sidebar-sub-header"><a href="/blog/http.html#密码学入门" class="sidebar-link">密码学入门</a></li><li class="sidebar-sub-header"><a href="/blog/http.html#https协议分析" class="sidebar-link">HTTPS协议分析</a></li><li class="sidebar-sub-header"><a href="/blog/http.html#http-2协议分析" class="sidebar-link">HTTP 2协议分析</a></li><li class="sidebar-sub-header"><a href="/blog/http.html#了解http-3" class="sidebar-link">了解HTTP 3</a></li><li class="sidebar-sub-header"><a href="/blog/http.html#http与反向代理" class="sidebar-link">HTTP与反向代理</a></li></ul></li><li><a href="/blog/write.html" class="sidebar-link">手写函数</a></li><li><a href="/blog/test.html" class="sidebar-link">习题总结</a></li><li><a href="/blog/arithmetic.html" class="sidebar-link">算法</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="http"><a href="#http" class="header-anchor">#</a> HTTP</h1> <h2 id="http-协议详解"><a href="#http-协议详解" class="header-anchor">#</a> HTTP 协议详解</h2> <h3 id="浏览器行为与http协议"><a href="#浏览器行为与http协议" class="header-anchor">#</a> 浏览器行为与HTTP协议</h3> <p>处理流程：</p> <ul><li>1、输入网址并回车</li> <li>2、解析域名</li> <li>3、浏览器发送HTTP请求</li> <li>4、服务器处理请求</li> <li>5、服务器返回HTML响应</li> <li>6、浏览器处理HTML页面</li> <li>7、继续请求其他资源</li></ul> <h3 id="什么是http协议"><a href="#什么是http协议" class="header-anchor">#</a> 什么是HTTP协议</h3> <ul><li>HTTP是超文本传输协议，从 www 浏览器传输到本地浏览器的一种传输协议，网站是基于HTTP协议的，例如网站的图片、css、js等都是基于HTTP协议进行传输的。</li> <li>HTTP协议是由从客户机到服务器的请求（Request）和从服务器到客户机的响应（response）进行约束和规范。</li></ul> <h3 id="了解tcp-ip协议栈"><a href="#了解tcp-ip协议栈" class="header-anchor">#</a> 了解TCP/IP协议栈</h3> <ul><li>应用层
<ul><li>为用户提供所需要的各种服务，例如：HTTP，FTP，DNS，SMTP等</li></ul></li> <li>传输层
<ul><li>为应用层实体提供端到端的通信功能，保证数据包的顺序传送及数据的完整性。</li> <li>该层定义了两个主要的协议：传输控制协议（TCP）和用户数据报协议（UDP）。</li></ul></li> <li>网络层
<ul><li>主要解决主机到主机的通信问题。IP协议是国际互联层最重要的协议。</li></ul></li> <li>网络接口层
<ul><li>负责监视数据在主机和网络之间的交换。
<img src="http_1.png" alt="tcp/ip"> <strong>在TCP/IP协议栈中的位置</strong> <img src="http_2.png" alt="http"></li></ul></li> <li>目前普遍应用版本HTTP 1.1</li> <li>正在逐步向HTTP 2迁移</li> <li>HTTP默认端口号为80</li> <li>HTTPS默认端口号为443</li></ul> <h3 id="http工作过程"><a href="#http工作过程" class="header-anchor">#</a> HTTP工作过程</h3> <p>事务：一个操作分为一个或几个步骤，每个步骤都有严格的顺序去执行，在任何一个步骤上错误，这个操作就是失败。</p> <p>一次HTTP操作称为一个事务，其工作过程可分为四步：</p> <ul><li>1)首先客户机与服务器需要建立连接。只要单击某个超级链接，HTTP的工作开始。</li> <li>2)建立连接后，客户机发送一个请求给服务器，请求方式的格式为：统一资源标识符(URL)、协议版本号，后边是MIME信息包括请求修饰符、客户机信息和可能的内容。</li> <li>3)服务器接到请求后，给予相应的响应信息，其格式为一个状态行，包括信息的协议版本号、一个成功或错误的代码，后边是MIME信息包括服务器信息、实体信息和可能的内容。</li> <li>4)客户端接收服务器所返回的信息通过浏览器显示在用户的显示屏上，然后客户机与服务器断开连接。</li> <li>如果在以上过程中的某一步出现错误，那么产生错误的信息将返回到客户端，有显示屏输出。对于用户来说，这些过程是由HTTP自己完成的，用户只要用鼠标点击，等待信息显示就可以了。</li></ul> <h3 id="请求与响应"><a href="#请求与响应" class="header-anchor">#</a> 请求与响应</h3> <ul><li>HTTP请求组成：请求行、消息报头、请求正文。</li> <li>HTTP响应组成：状态行、消息报头、响应正文。</li> <li>请求行组成：以一个方法符号开头，后面跟着请求的URI和协议的版本。</li> <li>状态行组成：服务器HTTP协议的版本，服务器发回的响应状态代码和状态代码的文本描述。</li></ul> <h3 id="请求方法"><a href="#请求方法" class="header-anchor">#</a> 请求方法</h3> <ul><li>GET： 请求获取Request-URI所标识的资源</li> <li>POST： 在Request-URI所标识的资源后附加新的数据</li> <li>HEAD： 请求获取由Request-URI所标识的资源的响应消息报头</li> <li>PUT： 请求服务器存储一个资源，并用Request-URI作为其标识</li> <li>DELETE： 请求服务器删除Request-URI所标识的资源</li> <li>TRACE： 请求服务器回送收到的请求信息，主要用于测试或诊断CONNECT：HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。OPTIONS： 请求查询服务器的性能，或者查询与资源相关的选项和需求</li></ul> <h3 id="http状态码"><a href="#http状态码" class="header-anchor">#</a> HTTP状态码</h3> <ul><li>状态代码有三位数字组成，第一个数字定义了响应的类别，且有五种可能取值：</li> <li>1xx：指示信息--表示请求已接收，继续处理</li> <li>2xx：成功--表示请求已被成功接收、理解、接受</li> <li>3xx：重定向--要完成请求必须进行更进一步的操作</li> <li>4xx：客户端错误--请求有语法错误或请求无法实现</li> <li>5xx：服务器端错误--服务器未能实现合法的请求</li></ul> <h3 id="常用的响应报头"><a href="#常用的响应报头" class="header-anchor">#</a> 常用的响应报头</h3> <ul><li>Location 响应报头域用于重定向接受者到一个新的位置。Location响应报头域常用在更换域名的时候。</li> <li>Server 响应报头域包含了服务器用来处理请求的软件信息。与UserAgent请求报头域是相对应的。</li> <li>WWW-Authenticate 响应报头域必须被包含在401（未授权的）响应消息中，客户端收到401响应消息时候，并发送Authorization报头域请求服务器对其进行验证时，服务端响应报头就包含该报头域。</li></ul> <p><strong>实体报头</strong>
请求和响应消息都可以传送一个实体。一个实体由实体报头域和实体正文组成，但并不是说实体报头域和实体正文要在一起发送，可以只发送实体报头域。实体报头定义了关于实体正文（eg：有无实体正文）和请求所标识的资源的元信息。</p> <h3 id="常用的实体报头"><a href="#常用的实体报头" class="header-anchor">#</a> 常用的实体报头</h3> <ul><li>Content-Encoding 实体报头域被用作媒体类型的修饰符，它的值指示了已经被应用到实体正文的附加内容的编码，因而要获得Content-Type报头域中所引用的媒体类型，必须采用相应的解码机制。</li> <li>Content-Language 实体报头域描述了资源所用的自然语言。</li> <li>Content-Length 实体报头域用于指明实体正文的长度，以字节方式存储的十进制数字来表示。</li> <li>Content-Type 实体报头域用语指明发送给接收者的实体正文的媒体类型。</li> <li>Last-Modified 实体报头域用于指示资源的最后修改日期和时间。</li> <li>Expires 实体报头域给出响应过期的日期和时间。</li></ul> <h2 id="cookies与session"><a href="#cookies与session" class="header-anchor">#</a> Cookies与Session</h2> <ul><li>Cookies是保存在客户端的小段文本，随客户端点每一个请求发送该url下的所有cookies到服务器端。</li> <li>Session则保存在服务器端，通过唯一的值sessionID来区别每一个用户。SessionID随每个连接请求发送到服务器，服务器根据sessionID来识别客户端，再通过session 的key获取session值。</li></ul> <h3 id="cookie使用"><a href="#cookie使用" class="header-anchor">#</a> Cookie使用</h3> <ul><li>与Cookie相关的HTTP扩展头</li> <li>1)Cookie：客户端将服务器设置的Cookie返回到服务器;</li> <li>2)Set-Cookie：服务器向客户端设置Cookie;</li> <li>服务器在响应消息中用Set-Cookie头将Cookie的内容回送给客户端，客户端在新的请求中将相同的内容携带在Cookie头中发送给服务器。从而实现会话的保持。
<img src="http_3.png" alt="cookie"></li></ul> <h3 id="session的使用"><a href="#session的使用" class="header-anchor">#</a> Session的使用</h3> <ul><li>使用Cookie来实现</li> <li>使用URL回显来实现
<img src="http_4.png" alt="session"></li></ul> <h2 id="http缓存机制"><a href="#http缓存机制" class="header-anchor">#</a> HTTP缓存机制</h2> <ul><li>缓存会根据请求保存输出内容的副本，例如html页面，图片，文件，当下一个请求来到的时候：如果是相同的URL，缓存直接使用副本响应访问请求，而不是向源服务器再次发送请求。</li> <li>缓存的优点：减少相应延迟,减少网络带宽消耗.</li></ul> <h3 id="浏览器缓存机制"><a href="#浏览器缓存机制" class="header-anchor">#</a> 浏览器缓存机制</h3> <p><img src="http_5.png" alt="无缓存"> <img src="http_6.png" alt="有缓存"></p> <h3 id="了解两种缓存策略"><a href="#了解两种缓存策略" class="header-anchor">#</a> 了解两种缓存策略</h3> <ul><li>强制缓存与对比缓存
<ul><li>强制缓存，服务器通知浏览器一个缓存时间，在缓存时间内，下次请求，直接用缓存，不在时间内，执行比较缓存策略。</li> <li>比较缓存，将缓存信息中的Etag和Last-Modified通过请求发送给服务器，由服务器校验，返回304状态码时，浏览器直接使用缓存。</li></ul></li> <li>Etag/If-None-Match策略</li> <li>Last-Modified/If-Modified-Since策略</li></ul> <p><strong>比较缓存</strong></p> <p>url、新窗口打开、前进后退，这三种情况下两种缓存都生效。</p> <p>F5刷新，直接走比较缓存，不走强制缓存。</p> <p>强制清缓存 ，两种都不生效。</p> <h2 id="密码学入门"><a href="#密码学入门" class="header-anchor">#</a> 密码学入门</h2> <ul><li>密码学的处理对象是数字和字符串。</li> <li>散列是一种数据一旦转换为其他形式将永远无法恢复的加密技术。</li> <li>加密
<ul><li>对称加密（AES、DES、3DES）</li> <li>非对称加密（RSA）</li></ul></li> <li>密钥交换算法
<ul><li>Diffie-Hellman算法是一种著名的密钥协商算法，这种算法可以使得信息交换的双方通过公开的非安全的网络协商生成安全的共享密钥。</li> <li>（1）Alice与Bob确定两个大素数n和g，这两个数不用保密</li> <li>（2）Alice选择另一个大随机数x，并计算A如下：A=gx mod n</li> <li>（3）Alice将A发给Bob</li> <li>（4）Bob选择另一个大随机数y，并计算B如下：B=gy mod n</li> <li>（5）Bob将B发给Alice</li> <li>（6）计算秘密密钥K1如下：K1=Bx mod n</li> <li>（7）计算秘密密钥K2如下：K2=Ay mod n</li> <li>K1=K2，因此Alice和Bob可以用其进行加解密</li></ul></li></ul> <h3 id="证书签发机构-ca"><a href="#证书签发机构-ca" class="header-anchor">#</a> 证书签发机构（CA）</h3> <ul><li><p>通过CA发放的证书完成密钥的交换，实际上是利用非对称的加密算法完成数据加密密钥的安全交换，然后再利用数据加密密钥完成数据的安全交换。</p></li> <li><p>数字证书：数字证书是互联网通信中标识双方身份信息的数字文件，由CA签发。</p></li> <li><p>CA：CA（certification authority）是数字证书的签发机构。作为权威机构，其审核申请者身份后签发数字证书，这样我们只需要校验数字证书即可确定对方的真实身份。</p></li> <li><p>CA的工作流程</p> <ul><li>1.服务器 example.com将从CA请求TLS证书，例如 Digicert。</li> <li>2.Digicert将为example.com创建证书，证书将包含必要的数据，例如服务器名称，服务器的公钥等。</li> <li>3.Digicert将创建数据（证书）的哈希值，并使用自己的私钥对其进行加密。</li> <li>4.浏览器和操作系统自带Digicert等权威机构的公钥。</li> <li>5.当浏览器收到签名证书时，它将使用公钥从签名生成哈希值，它还将使用证书中指定的散列算法生成数据（证书）的散列，如果两个哈希值匹配，则签名验证成功并且证书是可信的。</li> <li>6.现在浏览器可以使用证书中指定的example.com的公钥继续进行身份验证过程。</li> <li>在这里，我们可以将Digicert称为 Root CA。
<strong>浏览器如何验证服务器证书的有效性</strong></li></ul></li> <li><p>证书颁发机构是为服务器创建并签署证书，很少有组织从事这项工作，即Digicert，Geotrust，Comodo等。如果他们正在为所有服务器签署证书，则必须为所有签名使用相同的私钥，如果它被盗，那么所有的信任都会丢失。为了解决这个问题并增加更多的平均信息量，引入了中间CA(intermediate CA)的概念。</p></li> <li><p>服务器使用中级证书颁发机构的签名，因此，在与浏览器通信时，服务器将共享两个证书：</p> <ul><li>1、包含服务器的公钥，即实际的服务器证书；</li> <li>2、由 Root CA 颁发的 intermediate CA 证书。</li></ul></li> <li><p>在签名验证期间，浏览器首先使用已经存储在浏览器中的Root CA的公钥来验证中间证书的数字签名，如果成功，浏览器现在可以信任中间证书及其公钥。现在使用此公钥，浏览器将验证原始服务器证书的签名，该组织可以注册为intermediate CA，以便为其域签署证书。</p></li></ul> <h3 id="ssl-tls协议"><a href="#ssl-tls协议" class="header-anchor">#</a> SSL/TLS协议</h3> <ul><li>传输层安全性协议（Transport Layer Security - TLS），及其前身安全套接层（SecureSockets Layer - SSL）是一种安全协议，目的是为互联网通信提供安全及数据完整性保障。</li> <li>HTTPS协议的安全性由SSL协议实现，当前使用的TLS协议 1.2 版本包含了四个核心子协议：握手协议、密钥配置切换协议、应用数据协议及报警协议。
<ul><li>TLS适用于对称密钥</li> <li>对称密钥可以通过安全密钥交换算法共享</li> <li>如果请求被截获，密钥交换可能会被欺骗</li> <li>使用数字签名进行身份验证证书颁发机构和信任链。</li></ul></li> <li>HTTPS协议、SSL协议、TLS协议、握手协议的关系
<ul><li>HTTPS是Hypertext Transfer Protocol over Secure Socket Layer的缩写，即HTTPover SSL，可理解为基于SSL的HTTP协议。HTTPS协议安全是由SSL协议实现的。</li> <li>SSL协议是一种记录协议，扩展性良好，可以很方便的添加子协议</li> <li>握手协议是SSL协议的一个子协议。</li> <li>TLS协议是SSL协议的后续版本，本文中涉及的SSL协议默认是TLS协议1.2版本。</li></ul></li></ul> <h2 id="https协议分析"><a href="#https协议分析" class="header-anchor">#</a> HTTPS协议分析</h2> <ul><li>TLS 握手的步骤：
<ul><li><ol><li>ClientHello：客户端发送所支持的 SSL/TLS 最高协议版本号和所支持的加密算法集合及压缩方法集合等信息给服务器端。</li></ol></li> <li><ol start="2"><li>ServerHello：服务器端收到客户端信息后，选定双方都能够支持的 SSL/TLS 协议版本和加密方法及压缩方法，返回给客户端。</li></ol></li> <li><ol start="3"><li>SendCertificate（可选）：服务器端发送服务端证书给客户端。</li></ol></li> <li><ol start="4"><li>RequestCertificate（可选）：如果选择双向验证，服务器端向客户端请求客户端证书。</li></ol></li> <li><ol start="5"><li>ServerHelloDone：服务器端通知客户端初始协商结束。</li></ol></li> <li><ol start="6"><li>ResponseCertificate（可选）：如果选择双向验证，客户端向服务器端发送客户端证书。</li></ol></li> <li><ol start="7"><li>ClientKeyExchange：客户端使用服务器端的公钥，对客户端公钥和密钥种子进行加密，再发送给服务器端。</li></ol></li> <li><ol start="8"><li>CertificateVerify（可选）：如果选择双向验证，客户端用本地私钥生成数字签名，并发送给服务器端，让其通过收到的客户端公钥进行身份验证。</li></ol></li> <li><ol start="9"><li>CreateSecretKey：通讯双方基于密钥种子等信息生成通讯密钥。</li></ol></li> <li><ol start="10"><li>ChangeCipherSpec：客户端通知服务器端已将通讯方式切换到加密模式。</li></ol></li> <li><ol start="11"><li>Finished：客户端做好加密通讯的准备。</li></ol></li> <li><ol start="12"><li>ChangeCipherSpec：服务器端通知客户端已将通讯方式切换到加密模式。</li></ol></li> <li><ol start="13"><li>Finished：服务器做好加密通讯的准备。</li></ol></li> <li><ol start="14"><li>Encrypted/DecryptedData：双方使用客户端密钥，通过对称加密算法对通讯内容进行加密。</li></ol></li> <li><ol start="15"><li>ClosedConnection：通讯结束后，任何一方发出断开 SSL 连接的消息。</li></ol></li></ul></li></ul> <h2 id="http-2协议分析"><a href="#http-2协议分析" class="header-anchor">#</a> HTTP 2协议分析</h2> <ul><li>HTTP/2 没有改动 HTTP 的应用语义。 HTTP 方法、状态代码、URI 和标头字段等核心概念一如往常。</li> <li>HTTP/2 修改了数据格式化（分帧）以及在客户端与服务器间传输的方式。这两点统帅全局，通过新的分帧层向我们的应用隐藏了所有复杂性。</li> <li>由于HTTP/2 引入了一个新的二进制分帧层，该层无法与之前的 HTTP/1.x 服务器和客户端向后兼容，因此协议的主版本提升到 HTTP/2。</li> <li>HTTP2的特点：
<ul><li>使用二进制格式传输，更高效、更紧凑。</li> <li>对报头压缩，降低开销。</li> <li>多路复用，一个网络连接实现并行请求。</li> <li>服务器主动推送，减少请求的延迟</li> <li>默认使用加密
<img src="http_7.png" alt="http2"></li></ul></li></ul> <h3 id="http-2-二进制分帧层"><a href="#http-2-二进制分帧层" class="header-anchor">#</a> HTTP 2：二进制分帧层</h3> <ul><li>HTTP/2 所有性能增强的核心在于新的二进制分帧层，它定义了如何封装 HTTP 消息并在客户端与服务器之间传输。</li> <li>这里所谓的“层”指的是位于套接字接口与应用可见的高级 HTTP API 之间一个经过优化的新编码机制。</li> <li>HTTP/1.x 协议以换行符作为纯文本的分隔符，而HTTP/2 将所有传输的信息分割为更小的消息和帧，并采用二进制格式对它们编码。</li> <li>客户端和服务器会替我们完成必要的分帧工作。
<img src="http_8.png" alt="二进制"></li></ul> <h3 id="http-2-多路复用"><a href="#http-2-多路复用" class="header-anchor">#</a> HTTP 2：多路复用</h3> <ul><li>在 HTTP/1.x 中，如果客户端要想发起多个并行请求以提升性能，则必须使用多个 TCP 连接。这种模型也会导致队首阻塞，从而造成底层 TCP 连接的效率低下。
<img src="http_9.png" alt="多路"></li> <li>将 HTTP 消息分解为独立的帧，交错发送，然后在另一端重新组装是 HTTP2 最重要的一项增强。这个机制会在整个网络技术栈中引发一系列连锁反应，从而带来巨大的性能提升。
<ul><li>并行交错地发送多个请求，请求之间互不影响。</li> <li>并行交错地发送多个响应，响应之间互不干扰。</li> <li>使用一个连接并行发送多个请求和响应。</li> <li>不必再为绕过 HTTP/1.x 限制而做很多工作</li> <li>消除不必要的延迟和提高现有网络容量的利用率，从而减少页面加载时间。
<img src="http_10.png" alt="多路"></li></ul></li></ul> <h3 id="http-2-服务器推送"><a href="#http-2-服务器推送" class="header-anchor">#</a> HTTP 2：服务器推送</h3> <ul><li>HTTP/2 新增的另一个强大的新功能是，服务器可以对一个客户端请求发送多个响应。 换句话说，除了对最初请求的响应外，服务器还可以向客户端推送额外资源，而无需客户端明确地请求。</li> <li>HTTP/2 打破了严格的请求-响应语义，支持一对多和服务器发起的推送工作流</li> <li>服务器已经知道客户端下一步要请求什么资源，这时候服务器推送即可派上用场。</li> <li>推送资源可以进行以下处理：
<ul><li>由客户端缓存</li> <li>在不同页面之间重用</li> <li>与其他资源一起复用</li> <li>由服务器设定优先级</li> <li>被客户端拒绝</li></ul></li></ul> <h3 id="http2的伪头字段"><a href="#http2的伪头字段" class="header-anchor">#</a> HTTP2的伪头字段</h3> <ul><li>伪头部字段是http2内置的几个特殊的以”:”开始的key，用于替代HTTP/1.x中请求行/响应行中的信息，比如请求方法，响应状态码等:
<ul><li>method 目标URL模式部分（请求）</li> <li>:scheme 目标URL模式部分（请求）</li> <li>:authority 目标RUL认证部分（请求）</li> <li>:path 目标URL的路径和查询部分（绝对路径产生式和一个跟着&quot;？&quot;字符的查询产生式）。（请求）</li> <li>:status 响应头中的HTTP状态码部分（响应）</li></ul></li></ul> <h2 id="了解http-3"><a href="#了解http-3" class="header-anchor">#</a> 了解HTTP 3</h2> <ul><li>运行在 QUIC 之上的 HTTP 协议被称为 HTTP/3（HTTP-over-QUIC）</li> <li>QUIC 协议（Quick UDP Internet Connection）基于 UDP，正是看中了UDP 的速度与效率。同时 QUIC 也整合了 TCP、TLS 和 HTTP/2 的优点，并加以优化。</li> <li>特点：
<ul><li>减少了握手的延迟（1-RTT 或 0-RTT）</li> <li>多路复用，并且没有 TCP 的阻塞问题</li> <li>连接迁移，（主要是在客户端）当由 Wifi 转移到 4G 时，连接不会被断开。</li></ul></li> <li>HTTP 3与HTTP 1.1和HTTP 2没有直接的关系，也不是http2的扩展</li> <li>HTTP 3将会是一个全新的WEB协议</li> <li>HTTP 3目前处于制订和测试阶段
<img src="http_11.png" alt="http3"></li></ul> <h3 id="队首阻塞问题"><a href="#队首阻塞问题" class="header-anchor">#</a> 队首阻塞问题</h3> <ul><li>HTTP/1.1 和 HTTP/2 都存在队头阻塞问题（Head of line blocking）</li> <li>HTTP/1.1 的队头阻塞。一个 TCP 连接同时传输 10 个请求，其中第1、2、3 个请求已被客户端接收，但第 4 个请求丢失，那么后面第 5- 10 个请求都被阻塞，需要等第 4 个请求处理完毕才能被处理，这样就浪费了带宽资源。</li> <li>HTTP/2 的多路复用虽然可以解决“请求”这个粒度的阻塞，但 HTTP/2的基础 TCP 协议本身却也存在着队头阻塞的问题。</li> <li>由于 HTTP/2 必须使用 HTTPS，而 HTTPS 使用的 TLS 协议也存在队头阻塞问题。</li> <li>队头阻塞会导致 HTTP/2 在更容易丢包的弱网络环境下比 HTTP/1.1更慢</li> <li>那 QUIC 解决队头阻塞问题的的方法：
<ul><li>QUIC 的传输单元是 Packet，加密单元也是 Packet，整个加密、传输、解密都基于 Packet，这样就能避免 TLS 的队头阻塞问题；</li> <li>QUIC 基于 UDP，UDP 的数据包在接收端没有处理顺序，即使中间丢失一个包，也不会阻塞整条连接，其他的资源会被正常处理。</li></ul></li></ul> <h2 id="http与反向代理"><a href="#http与反向代理" class="header-anchor">#</a> HTTP与反向代理</h2> <h3 id="反向代理的用途"><a href="#反向代理的用途" class="header-anchor">#</a> 反向代理的用途</h3> <ul><li>加密和SSL加速</li> <li>负载均衡</li> <li>缓存静态内容</li> <li>压缩</li> <li>减速上传</li> <li>安全</li> <li>外网发布</li></ul> <h3 id="反向代理做负载均衡"><a href="#反向代理做负载均衡" class="header-anchor">#</a> 反向代理做负载均衡</h3> <p><img src="http_12.png" alt="反向"></p></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/blog/html.html" class="prev">
        同源和跨域
      </a></span> <span class="next"><a href="/blog/write.html">
        手写函数
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.a0896f0e.js" defer></script><script src="/assets/js/2.88eb2c00.js" defer></script><script src="/assets/js/17.be1e4a31.js" defer></script>
  </body>
</html>

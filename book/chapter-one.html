<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>你不知道的JavaScript（上卷）总结 | 前端日志</title>
    <meta name="generator" content="VuePress 1.9.5">
    
    <meta name="description" content="欢迎访问我的前端日志">
    
    <link rel="preload" href="/assets/css/0.styles.e1700646.css" as="style"><link rel="preload" href="/assets/js/app.a0896f0e.js" as="script"><link rel="preload" href="/assets/js/2.88eb2c00.js" as="script"><link rel="preload" href="/assets/js/35.f1909c5d.js" as="script"><link rel="prefetch" href="/assets/js/10.d30f3d8f.js"><link rel="prefetch" href="/assets/js/11.e2b957ff.js"><link rel="prefetch" href="/assets/js/12.2da1d6bb.js"><link rel="prefetch" href="/assets/js/13.8ce2c088.js"><link rel="prefetch" href="/assets/js/14.16109f84.js"><link rel="prefetch" href="/assets/js/15.93448cfb.js"><link rel="prefetch" href="/assets/js/16.6f18825f.js"><link rel="prefetch" href="/assets/js/17.be1e4a31.js"><link rel="prefetch" href="/assets/js/18.e635c0f4.js"><link rel="prefetch" href="/assets/js/19.be17ff30.js"><link rel="prefetch" href="/assets/js/20.d142b0c9.js"><link rel="prefetch" href="/assets/js/21.e40d6d09.js"><link rel="prefetch" href="/assets/js/22.071940ae.js"><link rel="prefetch" href="/assets/js/23.99088ae7.js"><link rel="prefetch" href="/assets/js/24.670dab57.js"><link rel="prefetch" href="/assets/js/25.85694927.js"><link rel="prefetch" href="/assets/js/26.461dcdb2.js"><link rel="prefetch" href="/assets/js/27.878ab7f9.js"><link rel="prefetch" href="/assets/js/28.1fcc3f4d.js"><link rel="prefetch" href="/assets/js/29.86923448.js"><link rel="prefetch" href="/assets/js/3.037aac60.js"><link rel="prefetch" href="/assets/js/30.724a5ac7.js"><link rel="prefetch" href="/assets/js/31.ac601726.js"><link rel="prefetch" href="/assets/js/32.765bf8d3.js"><link rel="prefetch" href="/assets/js/33.509ffbda.js"><link rel="prefetch" href="/assets/js/34.5aa96cf1.js"><link rel="prefetch" href="/assets/js/36.36538350.js"><link rel="prefetch" href="/assets/js/37.b9375bb3.js"><link rel="prefetch" href="/assets/js/38.193abee5.js"><link rel="prefetch" href="/assets/js/39.b584d1b5.js"><link rel="prefetch" href="/assets/js/4.a0809240.js"><link rel="prefetch" href="/assets/js/40.17832949.js"><link rel="prefetch" href="/assets/js/41.cde349a4.js"><link rel="prefetch" href="/assets/js/42.67b16448.js"><link rel="prefetch" href="/assets/js/43.1b5d99f6.js"><link rel="prefetch" href="/assets/js/44.9ecb1424.js"><link rel="prefetch" href="/assets/js/5.77c6fbd3.js"><link rel="prefetch" href="/assets/js/6.609d5ed0.js"><link rel="prefetch" href="/assets/js/7.9131668e.js"><link rel="prefetch" href="/assets/js/8.f1d4a37a.js"><link rel="prefetch" href="/assets/js/9.8be87860.js">
    <link rel="stylesheet" href="/assets/css/0.styles.e1700646.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">前端日志</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/blog/" class="nav-link">
  博客
</a></div><div class="nav-item"><a href="/combat/" class="nav-link">
  实战
</a></div><div class="nav-item"><a href="/book/" class="nav-link router-link-active">
  阅读
</a></div><div class="nav-item"><a href="https://github.com/wumao016" target="_blank" rel="noopener noreferrer" class="nav-link external">
  github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/blog/" class="nav-link">
  博客
</a></div><div class="nav-item"><a href="/combat/" class="nav-link">
  实战
</a></div><div class="nav-item"><a href="/book/" class="nav-link router-link-active">
  阅读
</a></div><div class="nav-item"><a href="https://github.com/wumao016" target="_blank" rel="noopener noreferrer" class="nav-link external">
  github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>你不知道的javascript上</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/book/chapter-one.html" aria-current="page" class="active sidebar-link">你不知道的JavaScript（上卷）总结</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/book/chapter-one.html#_1-作用域和闭包" class="sidebar-link">1.作用域和闭包</a></li><li class="sidebar-sub-header"><a href="/book/chapter-one.html#_2-this和对象原型" class="sidebar-link">2.this和对象原型</a></li></ul></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>漫画算法</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/book/chapter-two.html" class="sidebar-link">漫画算法 总结</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="你不知道的javascript-上卷-总结"><a href="#你不知道的javascript-上卷-总结" class="header-anchor">#</a> 你不知道的JavaScript（上卷）总结</h1> <h2 id="_1-作用域和闭包"><a href="#_1-作用域和闭包" class="header-anchor">#</a> 1.作用域和闭包</h2> <h3 id="_1-作用域是什么"><a href="#_1-作用域是什么" class="header-anchor">#</a> 1.作用域是什么</h3> <p><strong>1.1 编译原理</strong></p> <p>尽管通常将 JavaScript 归类为“动态” 或“解释执行” 语言， 但事实上它是一门编译语言。
但与传统的编译语言不同， 它不是提前编译的， 编译结果也不能在分布式系统中进行移植。
尽管如此， JavaScript 引擎进行编译的步骤和传统的编译语言非常相似， 在某些环节可能比预想的要复杂。
在<code>传统编译</code>语言的流程中， 程序中的一段源代码在执行之前会经历<code>三个步骤</code>， 统称为“编译”。</p> <ul><li><p>分词/词法分析（Tokenizing/Lexing）</p> <p>这个过程会将由字符组成的字符串分解成（对编程语言来说） 有意义的代码块， 这些代码块被称为词法单元（token）。
例如， 考虑程序 var a = 2;。 这段程序通常会被分解成为下面这些词法单元： var、 a、 =、 2 、 ;。
空格是否会被当作词法单元， 取决于空格在这门语言中是否具有意义。</p></li></ul> <blockquote><p>分词和词法分析</p> <p>分词（tokenizing） 和词法分析（Lexing）之间的区别是非常微妙、 晦涩的，主要差异在于词法单元的识别是通过有状态还是无状态的方式进行的。
简单来说， 如果词法单元生成器在判断 a 是一个独立的词法单元还是其他词法单元的一部分时， 调用的是有状态的解析规则， 那么这个过程就被称为词法分析。</p></blockquote> <ul><li><p>解析/语法分析（Parsing）</p> <p>这个过程是将词法单元流（数组） 转换成一个由元素逐级嵌套所组成的代表了程序语法结构的树。 这个树被称为“抽象语法树”（Abstract Syntax Tree， AST）。var a = 2; 的抽象语法树中可能会有一个叫作 VariableDeclaration 的顶级节点， 接下来是一个叫作 Identifier（它的值是 a） 的子节点， 以及一个叫作 AssignmentExpression的子节点。 AssignmentExpression 节点有一个叫作 NumericLiteral（ 它的值是 2） 的子节点。</p></li> <li><p>代码生成</p> <p>将 AST 转换为可执行代码的过程称被称为代码生成。 这个过程与语言、 目标平台等息息相关。抛开具体细节， 简单来说就是有某种方法可以将 var a = 2; 的 AST 转化为一组机器指令， 用来创建一个叫作 a 的变量（包括分配内存等）， 并将一个值储存在 a 中。</p></li></ul> <p>比起那些编译过程只有三个步骤的语言的编译器， JavaScript 引擎要<code>复杂</code>得多。</p> <p>首先，JavaScript 的编译过程不是发生在构建之前的。
大部分情况下编译发生在代码执行前的几微秒的时间内，JavaScript 引擎用尽了各种办法（比如 JIT， 可以延迟编译甚至实施重编译） 来保证性能最佳。
简单地说， 任何 JavaScript 代码片段在执行前都要进行编译（ 通常就在执行前）。
因此，JavaScript 编译器首先会对 var a = 2; 这段程序进行编译， 然后做好执行它的准备，并且通常马上就会执行它。</p> <p><strong>1.2 理解作用域</strong></p> <ul><li><p>引擎</p> <p>从头到尾负责整个 JavaScript 程序的编译及执行过程。</p></li> <li><p>编译器</p> <p>引擎的好朋友之一， 负责语法分析及代码生成等脏活累活（详见前一节的内容）。</p></li> <li><p>作用域</p> <p>引擎的另一位好朋友， 负责收集并维护由所有声明的标识符（变量） 组成的一系列查询， 并实施一套非常严格的规则， 确定当前执行的代码对这些标识符的访问权限。
为了能够完全理解 JavaScript 的工作原理， 你需要开始像引擎（和它的朋友们） 一样思考，从它们的角度提出问题， 并从它们的角度回答这些问题。</p></li></ul> <p><strong>1.2.3 编译器的LHS 查询和RHS 查询</strong></p> <p>当变量出现在赋值操作的左侧时进行 <code>LHS 查询</code>， 出现在右侧时进行 <code>RHS 查询</code>。</p> <p>讲得更准确一点， RHS 查询与简单地查找某个变量的值别无二致， 而 LHS 查询则是试图找到变量的容器本身， 从而可以对其赋值。 从这个角度说， RHS 并不是真正意义上的“赋值操作的右侧”， 更准确地说是“非左侧”。你可以将 RHS 理解成 retrieve his source value（ 取到它的源值）， 这意味着“得到某某的值“。</p> <p><strong>1.3 作用域嵌套</strong></p> <p>当一个块或函数嵌套在另一个块或函数中时， 就发生了作用域的嵌套。
因此， 在当前作用域中无法找到某个变量时， 引擎就会在外层嵌套的作用域中继续查找， 直到找到该变量，或抵达最外层的作用域（也就是全局作用域） 为止。</p> <p><strong>1.4 异常</strong></p> <p>ES5 中引入了“严格模式”。 同正常模式， 或者说宽松 / 懒惰模式相比， 严格模式在行为上有很多不同。
其中一个不同的行为是严格模式禁止自动或隐式地创建全局变量。 因此， 在严格模式中 LHS 查询失败时， 并不会创建并返回一个全局变量， 引擎会抛出同 RHS 查询失败时类似的 ReferenceError 异常。</p> <h3 id="_2-词法作用域"><a href="#_2-词法作用域" class="header-anchor">#</a> 2.词法作用域</h3> <p><strong>2.1词法阶段</strong></p> <p>简单地说， 词法作用域就是定义在词法阶段的作用域。 换句话说， 词法作用域是由你在写代码时将变量和块作用域写在哪里来决定的， 因此当词法分析器处理代码时会保持作用域不变（大部分情况下是这样的）。</p> <p><strong>2.2 欺骗词法</strong></p> <p>两种：eval，with（不推荐）</p> <p>欺骗词法作用域会导致性能下降。</p> <p><strong>2.3 小结</strong></p> <p>词法作用域意味着作用域是由书写代码时函数声明的位置来决定的。 编译的词法分析阶段基本能够知道全部标识符在哪里以及是如何声明的， 从而能够预测在执行过程中如何对它们进行查找。</p> <p>JavaScript 中有两个机制可以“欺骗” 词法作用域： eval(..) 和 with。 前者可以对一段包含一个或多个声明的“代码” 字符串进行演算， 并借此来修改已经存在的词法作用域（在运行时）。 后者本质上是通过将一个对象的引用当作作用域来处理， 将对象的属性当作作用域中的标识符来处理， 从而创建了一个新的词法作用域（同样是在运行时）。</p> <p>这两个机制的副作用是引擎无法在编译时对作用域查找进行优化， 因为引擎只能谨慎地认为这样的优化是无效的。 使用这其中任何一个机制都将导致代码运行变慢。 不要使用它们。</p> <h3 id="_3-函数作用域和块作用域"><a href="#_3-函数作用域和块作用域" class="header-anchor">#</a> 3.函数作用域和块作用域</h3> <p><strong>3.1 函数中的作用域</strong></p> <p>无论标识符声明出现在作用域中的何处， 这个标识符所代表的变量或函数都将附属于所处作用域的气泡。</p> <p>函数作用域的含义是指， 属于这个函数的全部变量都可以在整个函数的范围内使用及复用（ 事实上在嵌套的作用域中也可以使用）。 这种设计方案是非常有用的， 能充分利用JavaScript 变量可以根据需要改变值类型的“动态” 特性。</p> <p><strong>3.2 隐藏内部实现</strong></p> <p>可以把变量和函数包裹在一个函数的作用域中， 然后用这个作用域来“隐藏” 它们。</p> <p><strong>3.3 函数作用域</strong></p> <blockquote><p>区分函数声明和表达式最简单的方法是看 function 关键字出现在声明中的位置（不仅仅是一行代码， 而是整个声明中的位置）。 如果 function 是声明中的第一个词， 那么就是一个函数声明， 否则就是一个函数表达式。</p></blockquote> <p>函数声明和函数表达式之间最重要的区别是它们的名称标识符将会绑定在何处。</p> <p>函数声明 被绑定在所在作用域中， 可以直接通过函数名 来调用它。 函数表达式自身的函数中而不是所在作用域中。</p> <p>介绍 匿名和具名、（IIFE）立即执行函数表达式。</p> <p>IIFE 的另一个非常普遍的进阶用法是把它们当作函数调用并传递参数进去。</p> <p><strong>3.4 块作用域</strong></p> <p>with、try/catch 、let、const。</p> <p>ES6 引入了新的 let 关键字， 提供了除 var 以外的另一种变量声明方式。let 关键字可以将变量绑定到所在的任意作用域中（通常是 { .. } 内部）。let 进行的声明不会在块作用域中进行提升</p> <p>另一个块作用域非常有用的原因和闭包及回收内存垃圾的回收机制相关。</p> <p>一个 let 可以发挥优势的典型例子就是之前讨论的 for 循环。</p> <p>for 循环头部的 let 不仅将 i 绑定到了 for 循环的块中， 事实上它将其重新绑定到了循环的每一个迭代中， 确保使用上一个循环迭代结束时的值重新进行赋值。</p> <p>除了 let 以外， ES6 还引入了 const， 同样可以用来创建块作用域变量， 但其值是固定的（常量）。</p> <p><strong>3.5 小结</strong></p> <p>函数是 JavaScript 中最常见的作用域单元。 本质上， 声明在一个函数内部的变量或函数会在所处的作用域中“隐藏” 起来， 这是有意为之的良好软件的设计原则。但函数不是唯一的作用域单元。 块作用域指的是变量和函数不仅可以属于所处的作用域，也可以属于某个代码块（通常指 { .. } 内部）。从 ES3 开始， try/catch 结构在 catch 分句中具有块作用域。在 ES6 中引入了 let 关键字（var 关键字的表亲）， 用来在任意代码块中声明变量。 if(..) { let a = 2; } 会声明一个劫持了 if 的 { .. } 块的变量， 并且将变量添加到这个块中。有些人认为块作用域不应该完全作为函数作用域的替代方案。 两种功能应该同时存在， 开发者可以并且也应该根据需要选择使用何种作用域， 创造可读、 可维护的优良代码。</p> <h3 id="_4-提升"><a href="#_4-提升" class="header-anchor">#</a> 4.提升</h3> <ul><li>只有声明本身会被提升， 而赋值或其他运行逻辑会留在原地。</li> <li>函数声明会被提升， 但是函数表达式却不会被提升。</li> <li>函数声明和变量声明都会被提升。 是函数会首先被提升， 然后才是变量。</li></ul> <p><strong>小结</strong></p> <p>我们习惯将 var a = 2; 看作一个声明， 而实际上 JavaScript 引擎并不这么认为。 它将 var a和 a = 2 当作两个单独的声明， 第一个是编译阶段的任务， 而第二个则是执行阶段的任务。
这意味着无论作用域中的声明出现在什么地方， 都将在代码本身被执行前首先进行处理。可以将这个过程形象地想象成所有的声明（变量和函数） 都会被“移动” 到各自作用域的最顶端， 这个过程被称为提升。
要注意避免重复声明， 特别是当普通的 var 声明和函数声明混合在一起的时候， 否则会引起很多危险的问题！</p> <h3 id="_5-作用域闭包"><a href="#_5-作用域闭包" class="header-anchor">#</a> 5.作用域闭包</h3> <p><strong>5.1 启示</strong></p> <p>闭包是基于词法作用域书写代码时所产生的自然结果， 你甚至不需要为了利用它们而有意识地创建闭包。 闭包的创建和使用在你的代码中随处可见。</p> <p><strong>5.2 实质问题</strong></p> <p>当函数可以记住并访问所在的词法作用域时， 就产生了闭包， 即使函数是在当前词法作用域之外执行。</p> <p>下面我们来看一段代码， 清晰地展示了闭包：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
	<span class="token keyword">function</span> <span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> a <span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
		<span class="token keyword">return</span> bar<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">var</span> baz <span class="token operator">=</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">baz</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 2 —— 这就是闭包的效果.</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>函数 bar() 的词法作用域能够访问 foo() 的内部作用域。 然后我们将 bar() 函数本身当作一个值类型进行传递。 在这个例子中， 我们将 bar 所引用的函数对象本身当作返回值。</p> <p>在 foo() 执行后， 其返回值（也就是内部的 bar() 函数） 赋值给变量 baz 并调用 baz()， 实际上只是通过不同的标识符引用调用了内部的函数 bar()。</p> <p>bar() 显然可以被正常执行。 但是在这个例子中， 它在自己定义的词法作用域以外的地方执行。</p> <p><strong>5.3</strong></p> <p>如果将函数（访问它们各自的词法作用域） 当作第一级的值类型并到处传递， 你就会看到闭包在这些函数中的应用。 在定时器、 事件监听器、Ajax 请求、 跨窗口通信、 Web Workers 或者任何其他的异步（或者同步） 任务中， 只要使用了回调函数， 实际上就是在使用闭包！</p> <p><strong>5.4 循环和闭包</strong></p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">&lt;=</span><span class="token number">5</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">j</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token function">setTimeout</span><span class="token punctuation">(</span> <span class="token keyword">function</span> <span class="token function">timer</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
			console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> j <span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span><span class="token punctuation">,</span> j<span class="token operator">*</span><span class="token number">1000</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span> i <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p><strong>5.5 模块</strong></p> <p>如果要更简单的描述， 模块模式需要具备两个必要条件。</p> <ul><li><ol><li>必须有外部的封闭函数， 该函数必须至少被调用一次（每次调用都会创建一个新的模块实例）。</li></ol></li> <li><ol start="2"><li>封闭函数必须返回至少一个内部函数， 这样内部函数才能在私有作用域中形成闭包， 并且可以访问或者修改私有的状态。</li></ol></li></ul> <p><strong>5.6 小结</strong></p> <p>当函数可以记住并访问所在的词法作用域， 即使函数是在当前词法作用域之外执行， 这时就产生了闭包。</p> <p>模块有两个主要特征：（1） 为创建内部作用域而调用了一个包装函数；（2） 包装函数的返回值必须至少包括一个对内部函数的引用， 这样就会创建涵盖整个包装函数内部作用域的闭包。</p> <h2 id="_2-this和对象原型"><a href="#_2-this和对象原型" class="header-anchor">#</a> 2.this和对象原型</h2> <h3 id="_1-关于-this"><a href="#_1-关于-this" class="header-anchor">#</a> 1.关于 this</h3> <p><strong>1.1 为什么要用this</strong></p> <p>this 提供了一种更优雅的方式来隐式“传递” 一个对象引用， 因此可以将 API 设计得更加简洁并且易于复用。</p> <p><strong>1.2 误解</strong></p> <p>误区一：指向自身。误区二：this 指向函数的作用域。</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token parameter">num</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> <span class="token string">&quot;foo: &quot;</span> <span class="token operator">+</span> num <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 记录 foo 被调用的次数</span>
	<span class="token keyword">this</span><span class="token punctuation">.</span>count<span class="token operator">++</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span> 
foo<span class="token punctuation">.</span>count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> i<span class="token punctuation">;</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span><span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">&gt;</span> <span class="token number">5</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token function">foo</span><span class="token punctuation">(</span> i <span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span> 
<span class="token comment">// foo: 6</span>
<span class="token comment">// foo: 7</span>
<span class="token comment">// foo: 8</span>
<span class="token comment">// foo: 9</span>
<span class="token comment">// foo 被调用了多少次？console.log( foo.count ); // 0</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br></div></div><p><strong>1.3 this到底是什么</strong></p> <p>this 的绑定和函数声明的位置没有任何关系， 只取决于函数的调用方式.</p> <p><strong>1.4 小结</strong></p> <p>学习 this 的第一步是明白 this 既不指向函数自身也不指向函数的词法作用域， 你也许被这样的解释误导过， 但其实它们都是错误的。</p> <p>this 实际上是在函数被调用时发生的绑定， 它指向什么完全取决于函数在哪里被调用。</p> <h3 id="_2-this全面解析"><a href="#_2-this全面解析" class="header-anchor">#</a> 2.this全面解析</h3> <p><strong>2.1 调用位置</strong></p> <p>在理解 this 的绑定过程之前， 首先要理解调用位置： 调用位置就是函数在代码中被调用的位置（而不是声明的位置）。 只有仔细分析调用位置才能回答这个问题： 这个 this 到底引用的是什么？</p> <p>通常来说， 寻找调用位置就是寻找“函数被调用的位置”， 但是做起来并没有这么简单，因为某些编程模式可能会隐藏真正的调用位置。</p> <p>最重要的是要分析调用栈。</p> <p><strong>2.2 绑定规则</strong></p> <p>四种绑定this方法：</p> <p>1.默认绑定。函数调用时，是直接使用不带任何修饰的函数引用进行调用的，是使用默认绑定。如果使用严格模式（strict mode）， 那么全局对象将无法使用默认绑定， 因此 this 会绑定到 undefined。</p> <p>2.隐式绑定。 隐式绑定规则会把函数调用中的 this 绑定到这个上下文对象。</p> <p>3.显式绑定。 call(..) 和apply(..) 方法。它们的第一个参数是一个对象， 它们会把这个对象绑定到this， 接着在调用函数时指定这个 this。 因为你可以直接指定 this 的绑定对象， 因此我们称之为显式绑定。</p> <p>硬绑定。硬绑定就是绑定一次后就不能再修改了。显式绑定的一个变种可以实现硬绑。</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code>	<span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token parameter">something</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> <span class="token keyword">this</span><span class="token punctuation">.</span>a<span class="token punctuation">,</span> something <span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>a <span class="token operator">+</span> something<span class="token punctuation">;</span>
	<span class="token punctuation">}</span> <span class="token comment">// 简单的辅助绑定函数</span>
	<span class="token keyword">function</span> <span class="token function">bind</span><span class="token punctuation">(</span><span class="token parameter">fn<span class="token punctuation">,</span> obj</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">//这里加了一个return function是因为有两个参数fn，obj会影响arguments。在bar()调用的时候才会执行，才是真正要用的arguments</span>
			<span class="token keyword">return</span> <span class="token function">fn</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span> obj<span class="token punctuation">,</span> arguments <span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>a<span class="token operator">:</span><span class="token number">2</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
	<span class="token keyword">var</span> bar <span class="token operator">=</span> <span class="token function">bind</span><span class="token punctuation">(</span> foo<span class="token punctuation">,</span> obj <span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">var</span> b <span class="token operator">=</span> <span class="token function">bar</span><span class="token punctuation">(</span> <span class="token number">3</span> <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 2 3</span>
	console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> b <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 5</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><p>API调用的“上下文”</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code>	<span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token parameter">el</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> el<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>id <span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>id<span class="token operator">:</span> <span class="token string">&quot;awesome&quot;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment">// 调用 foo(..) 时把 this 绑定到 obj</span>
	<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span> foo<span class="token punctuation">,</span> obj <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 1 awesome 2 awesome 3 awesome</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>4.new绑定.使用 new 来调用函数， 或者说发生构造函数调用时， 会自动执行下面的操作。</p> <ul><li><ol><li>创建（或者说构造） 一个全新的对象。</li></ol></li> <li><ol start="2"><li>这个新对象会被执行 [[ 原型 ]] 连接。</li></ol></li> <li><ol start="3"><li>这个新对象会绑定到函数调用的 this。</li></ol></li> <li><ol start="4"><li>如果函数没有返回其他对象， 那么 new 表达式中的函数调用会自动返回这个新对象。</li></ol></li></ul> <p><strong>2.3 优先级</strong></p> <p>显式绑定优先级比隐式绑定更高。</p> <p>new 绑定比隐式绑定优先级高。</p> <p>MDN 提供的一种bind(..) 实现：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token class-name">Function</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>bind<span class="token punctuation">)</span> <span class="token punctuation">{</span>
   	<span class="token class-name">Function</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">bind</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">oThis</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
   		<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> <span class="token keyword">this</span> <span class="token operator">!==</span> <span class="token string">&quot;function&quot;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
   			<span class="token comment">// 与 ECMAScript 5 最接近的</span>
   			<span class="token comment">// 内部 IsCallable 函数</span>
   			<span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">TypeError</span><span class="token punctuation">(</span><span class="token string">&quot;Function.prototype.bind - what is trying &quot;</span> <span class="token operator">+</span><span class="token string">&quot;to be bound is not callable&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
   		<span class="token punctuation">}</span>
   		<span class="token keyword">var</span> aArgs <span class="token operator">=</span> <span class="token class-name">Array</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span> arguments<span class="token punctuation">,</span> <span class="token number">1</span> <span class="token punctuation">)</span><span class="token punctuation">,</span>
   		fToBind <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">,</span>
   		<span class="token function-variable function">fNOP</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
   		<span class="token function-variable function">fBound</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
   			<span class="token keyword">return</span> <span class="token function">fToBind</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>
   			<span class="token punctuation">(</span><span class="token keyword">this</span> <span class="token keyword">instanceof</span> <span class="token class-name">fNOP</span> <span class="token operator">&amp;&amp;</span>oThis <span class="token operator">?</span> <span class="token keyword">this</span> <span class="token operator">:</span> oThis<span class="token punctuation">)</span><span class="token punctuation">,</span>
   				aArgs<span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">(</span><span class="token class-name">Array</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span> arguments <span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
   			<span class="token punctuation">}</span><span class="token punctuation">;</span> 
   			fNOP<span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>prototype<span class="token punctuation">;</span>
   			fBound<span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">fNOP</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
   			<span class="token keyword">return</span> fBound<span class="token punctuation">;</span>
   			<span class="token punctuation">}</span><span class="token punctuation">;</span>
   			<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br></div></div><p><strong>2.4 绑定例外</strong></p> <p>1.如果你把 null 或者 undefined 作为 this 的绑定对象传入 call、 apply 或者 bind， 这些值在调用时会被忽略， 实际应用的是默认绑定规则.
2.间接引用,在这种情况下， 调用这个函数会应用默认绑定规则。
3.软绑定.如果可以给默认绑定指定一个全局对象和 undefined 以外的值， 那就可以实现和硬绑定相同的效果， 同时保留隐式绑定或者显式绑定修改 this 的能力。就是可以一直绑，如果是全局就绑默认对象</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token class-name">Function</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>softBind<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">Function</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">softBind</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">obj</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
   	 <span class="token keyword">var</span> fn <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span><span class="token comment">// 捕获所有 curried 参数</span>
   	 <span class="token keyword">var</span> curried <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span> arguments<span class="token punctuation">,</span> <span class="token number">1</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>		 
   	 <span class="token keyword">var</span> <span class="token function-variable function">bound</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
   		 <span class="token keyword">return</span> <span class="token function">fn</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>
   		 <span class="token punctuation">(</span><span class="token operator">!</span><span class="token keyword">this</span> <span class="token operator">||</span> <span class="token keyword">this</span> <span class="token operator">===</span> <span class="token punctuation">(</span>window <span class="token operator">||</span> global<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">?</span>obj <span class="token operator">:</span> thiscurried<span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span> curried<span class="token punctuation">,</span> arguments <span class="token punctuation">)</span>
   		 <span class="token punctuation">)</span><span class="token punctuation">;</span>
   		 <span class="token punctuation">}</span><span class="token punctuation">;</span>
   		 bound<span class="token punctuation">.</span>prototype <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span> fn<span class="token punctuation">.</span>prototype <span class="token punctuation">)</span><span class="token punctuation">;</span>
   		 <span class="token keyword">return</span> bound<span class="token punctuation">;</span>
   		 <span class="token punctuation">}</span><span class="token punctuation">;</span>
   		 <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><p><strong>2.5 this词法</strong></p> <p>箭头函数不使用 this 的四种标准规则， 而是根据外层（函数或者全局） 作用域来决定 this。</p> <p><strong>2.6 小结</strong></p> <p>如果要判断一个运行中函数的 this 绑定， 就需要找到这个函数的直接调用位置。 找到之后就可以顺序应用下面这四条规则来判断 this 的绑定对象。</p> <ol><li><p>由 new 调用？ 绑定到新创建的对象。</p></li> <li><p>由 call 或者 apply（或者 bind） 调用？ 绑定到指定的对象。</p></li> <li><p>由上下文对象调用？ 绑定到那个上下文对象。</p></li> <li><p>默认： 在严格模式下绑定到 undefined， 否则绑定到全局对象。</p></li></ol> <p>一定要注意， 有些调用可能在无意中使用默认绑定规则。 如果想“更安全” 地忽略 this 绑定， 你可以使用一个 DMZ 对象， 比如 ø = Object.create(null)， 以保护全局对象。</p> <p>ES6 中的箭头函数并不会使用四条标准的绑定规则， 而是根据当前的词法作用域来决定this， 具体来说， 箭头函数会继承外层函数调用的 this 绑定（无论 this 绑定到什么）。 这其实和 ES6 之前代码中的 self = this 机制一样。</p> <h3 id="_3-对象"><a href="#_3-对象" class="header-anchor">#</a> 3.对象</h3> <p><strong>3.1 语法</strong></p> <p>对象可以通过两种形式定义： 声明（文字） 形式和构造形式。</p> <p>对象的文字语法大概是这样：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">var</span> myObj <span class="token operator">=</span> <span class="token punctuation">{</span>key<span class="token operator">:</span> value<span class="token comment">// ...};</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>构造形式大概是这样：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">var</span> myObj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
myObj<span class="token punctuation">.</span>key <span class="token operator">=</span> value<span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>构造形式和文字形式生成的对象是一样的。 唯一的区别是， 在文字声明中你可以添加多个键 / 值对， 但是在构造形式中你必须逐个添加属性。</p> <p><strong>3.2类型</strong></p> <p>对象是 JavaScript 的基础。 在 JavaScript 中一共有六种主要类型（术语是“语言类型”） ：</p> <ul><li>string</li> <li>number</li> <li>boolean</li> <li>null</li> <li>undefined</li> <li>object
注意， 简单基本类型（string、 boolean、 number、 null 和 undefined） 本身并不是对象。null 有时会被当作一种对象类型， 但是这其实只是语言本身的一个 bug， 即对 null 执行typeof null 时会返回字符串 &quot;object&quot;。 1 实际上， null 本身是基本类型。</li></ul> <p>JavaScript 中还有一些对象子类型， 通常被称为内置对象。</p> <ul><li>String</li> <li>Number</li> <li>Boolean</li> <li>Object</li> <li>Function</li> <li>Array</li> <li>Date</li> <li>RegExp</li> <li>Error</li></ul> <p><strong>3.3 内容</strong></p> <p>对象的内容是由一些存储在特定命名位置的（任意类型的） 值组成的，我们称之为属性。</p> <p><code>可计算属性名</code>。ES6 增加了可计算属性名， 可以在文字形式中使用 [] 包裹一个表达式来当作属性名。</p> <p><code>数组</code>。数组也是对象， 所以虽然每个下标都是整数， 你仍然可以给数组添加属性。</p> <p><code>复制对象</code>。</p> <ul><li><p>var newObj = JSON.parse( JSON.stringify( someObj ) );当然， 这种方法需要保证对象是 JSON 安全的， 所以只适用于部分情况。</p></li> <li><p>ES6 定义了 Object.assign(..) 方法来实现浅复制。 Object.assign(..) 方法的第一个参数是目标对象， 之后还可以跟一个或多个源对象。 它会遍历一个或多个源对象的所有可枚举（enumerable， 参见下面的代码）的自有键（owned key， 很快会介绍） 并把它们复制（使用 = 操作符赋值） 到目标对象， 最后返回目标对象
<code>属性描述符</code>.ES5 开始， 所有的属性都具备了属性描述符。使用 Object.defineProperty(..)对特性进行设置.</p></li></ul> <p><code>不变性</code>.在 ES5 中可以通过很多种方法来实现。</p> <p><code>[[Get]] 操作</code>,<code>[[Put]]</code>对象默认的 [[Put]] 和 [[Get]] 操作分别可以控制属性值的设置和获取.</p> <p><code>Getter和Setter</code>getter 是一个隐藏函数， 会在获取属性值时调用。 setter 也是一个隐藏函数， 会在设置属性值时调用。</p> <p><code>存在性</code>,in 和 hasOwnProperty(..) 的区别在于是否查找 [[Prototype]] 链， 然而， Object.keys(..)和 Object.getOwnPropertyNames(..) 都只会查找对象直接包含的属性。</p> <p><strong>3.4 遍历</strong></p> <p>for..in 循环可以用来遍历对象的可枚举属性列表（包括 [[Prototype]] 链）。</p> <p>ES5 中增加了一些数组的辅助迭代器， 包括 forEach(..)、 every(..) 和 some(..)。 每种辅助迭代器都可以接受一个回调函数并把它应用到数组的每个元素上， 唯一的区别就是它们对于回调函数返回值的处理方式不同。</p> <p>forEach(..) 会遍历数组中的所有值并忽略回调函数的返回值。 every(..) 会一直运行直到回调函数返回 false（或者“假” 值）， some(..) 会一直运行直到回调函数返回 true（或者“真” 值）。</p> <p>every(..) 和 some(..) 中特殊的返回值和普通 for 循环中的 break 语句类似， 它们会提前终止遍历。</p> <p>ES6 增加了一种用来遍历数组的 for..of 循环语法.</p> <p><strong>3.5 小结</strong></p> <p>JavaScript 中的对象有字面形式（比如 var a = { .. }） 和构造形式（比如 var a = newArray(..)）。 字面形式更常用， 不过有时候构造形式可以提供更多选项。</p> <p>许多人都以为“JavaScript 中万物都是对象”， 这是错误的。 对象是 6 个（或者是 7 个， 取决于你的观点） 基础类型之一。 对象有包括 function 在内的子类型， 不同子类型具有不同的行为， 比如内部标签 [object Array] 表示这是对象的子类型数组。</p> <p>对象就是键 / 值对的集合。 可以通过 .propName 或者 [&quot;propName&quot;] 语法来获取属性值。 访问属性时， 引擎实际上会调用内部的默认 [[Get]] 操作（ 在设置属性值时是 [[Put]]），[[Get]] 操作会检查对象本身是否包含这个属性， 如果没找到的话还会查找 [[Prototype]]链（参见第 5 章）。</p> <p>属性的特性可以通过属性描述符来控制， 比如 writable 和 configurable。 此外， 可以使用Object.preventExtensions(..)、 Object.seal(..) 和 Object.freeze(..) 来设置对象（及其属性） 的不可变性级别。</p> <p>属性不一定包含值——它们可能是具备 getter/setter 的“访问描述符”。 此外， 属性可以是可枚举或者不可枚举的， 这决定了它们是否会出现在 for..in 循环中。</p> <p>你可以使用 ES6 的 for..of 语法来遍历数据结构（ 数组、 对象， 等等） 中的值， for..of会寻找内置或者自定义的 @@iterator 对象并调用它的 next() 方法来遍历数据值。</p> <h3 id="混合对象-类"><a href="#混合对象-类" class="header-anchor">#</a> 混合对象“类&quot;</h3> <p><strong>4.1 类理论</strong></p> <p>类 / 继承描述了一种代码的组织结构形式——一种在软件中对真实世界中问题领域的建模方法。</p> <p><strong>4.2 类的机制</strong></p> <p>类仅仅是一个抽象的表示， 它描述了所有“栈” 需要做的事， 但是它本身并不是一个“栈”。 你必须先实例化 类然后才能对它进行操作。</p> <p><strong>4.3 类的继承</strong></p> <p>在面向类的语言中， 你可以先定义一个类， 然后定义一个继承前者的类。</p> <p><code>多态</code>.例子中Car 重写了继承自父类的 drive() 方法， 但是之后 Car 调用了 inherited:drive() 方法，这表明 Car 可以引用继承来的原始 drive() 方法。 快艇的 pilot() 方法同样引用了原始drive() 方法。</p> <p><strong>4.4 混入</strong></p> <p>JavaScript 开发者也想出了一个方法来模拟类的复制行为， 这个方法就是混入。两种类型的混入： 显式和隐式。</p> <ul><li>显式混入</li></ul> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token comment">// 非常简单的 mixin(..) 例子 :</span>
<span class="token keyword">function</span> <span class="token function">mixin</span><span class="token punctuation">(</span> <span class="token parameter">sourceObj<span class="token punctuation">,</span> targetObj</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> key <span class="token keyword">in</span> sourceObj<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  	  <span class="token comment">// 只会在不存在的情况下复制</span>
  	  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span>key <span class="token keyword">in</span> targetObj<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  		  targetObj<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> sourceObj<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">;</span>
  		  <span class="token punctuation">}</span>
  		<span class="token punctuation">}</span>
  		<span class="token keyword">return</span> targetObj<span class="token punctuation">;</span>
  	<span class="token punctuation">}</span>
  	<span class="token keyword">var</span> Vehicle <span class="token operator">=</span> <span class="token punctuation">{</span>
  		engines<span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span>
  		<span class="token function-variable function">ignition</span><span class="token operator">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  			console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> <span class="token string">&quot;Turning on my engine.&quot;</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
  		<span class="token punctuation">}</span><span class="token punctuation">,</span>
  		<span class="token function-variable function">drive</span><span class="token operator">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  			<span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">ignition</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  			console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> <span class="token string">&quot;Steering and moving forward!&quot;</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
  		<span class="token punctuation">}</span>
  	<span class="token punctuation">}</span><span class="token punctuation">;</span>
  	<span class="token keyword">var</span> Car <span class="token operator">=</span> <span class="token function">mixin</span><span class="token punctuation">(</span> Vehicle<span class="token punctuation">,</span> <span class="token punctuation">{</span>
  		wheels<span class="token operator">:</span> <span class="token number">4</span><span class="token punctuation">,</span>
  		<span class="token function-variable function">drive</span><span class="token operator">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  			Vehicle<span class="token punctuation">.</span><span class="token function">drive</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span> <span class="token keyword">this</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
  			console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;Rolling on all &quot;</span> <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span>wheels <span class="token operator">+</span> <span class="token string">&quot; wheels!&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br></div></div><p>混合复制</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token comment">// 另一种混入函数， 可能有重写风险</span>
<span class="token keyword">function</span> <span class="token function">mixin</span><span class="token punctuation">(</span> <span class="token parameter">sourceObj<span class="token punctuation">,</span> targetObj</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> key <span class="token keyword">in</span> sourceObj<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  	  targetObj<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> sourceObj<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">;</span>
  	 <span class="token punctuation">}</span>
  	 <span class="token keyword">return</span> targetObj<span class="token punctuation">;</span>
  	<span class="token punctuation">}</span>
  	<span class="token keyword">var</span> Vehicle <span class="token operator">=</span> <span class="token punctuation">{</span>
  		<span class="token comment">// ...</span>
  	<span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment">// 首先创建一个空对象并把 Vehicle 的内容复制进去</span>
  	<span class="token keyword">var</span> Car <span class="token operator">=</span> <span class="token function">mixin</span><span class="token punctuation">(</span> Vehicle<span class="token punctuation">,</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span> <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 然后把新内容复制到 Car 中</span>
  	<span class="token function">mixin</span><span class="token punctuation">(</span> <span class="token punctuation">{</span>wheels<span class="token operator">:</span> <span class="token number">4</span><span class="token punctuation">,</span><span class="token function-variable function">drive</span><span class="token operator">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  		<span class="token comment">// ...</span>
  		<span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">,</span> Car <span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><p>寄生继承.显式混入模式的一种变体被称为“寄生继承”， 它既是显式的又是隐式的.</p> <p><strong>4.5 小结</strong></p> <p>类是一种设计模式。 许多语言提供了对于面向类软件设计的原生语法。 JavaScript 也有类似的语法， 但是和其他语言中的类完全不同。</p> <p>类意味着复制。</p> <p>传统的类被实例化时， 它的行为会被复制到实例中。 类被继承时， 行为也会被复制到子类中。</p> <p>多态（在继承链的不同层次名称相同但是功能不同的函数） 看起来似乎是从子类引用父类， 但是本质上引用的其实是复制的结果。</p> <p>JavaScript 并不会（像类那样） 自动创建对象的副本。</p> <p>混入模式（无论显式还是隐式） 可以用来模拟类的复制行为， 但是通常会产生丑陋并且脆弱的语法， 比如显式伪多态（OtherObj.methodName.call(this, ...)）， 这会让代码更加难懂并且难以维护.</p> <p>此外， 显式混入实际上无法完全模拟类的复制行为， 因为对象（和函数！ 别忘了函数也是对象） 只能复制引用， 无法复制被引用的对象或者函数本身。 忽视这一点会导致许多问题。</p> <p>总地来说， 在 JavaScript 中模拟类是得不偿失的， 虽然能解决当前的问题， 但是可能会埋下更多的隐患。</p> <h3 id="原型"><a href="#原型" class="header-anchor">#</a> 原型</h3> <p><strong>5.1 [[Prototype]]</strong></p> <p>JavaScript 中的对象有一个特殊的 [[Prototype]] 内置属性， 其实就是对于其他对象的引用。 几乎所有的对象在创建时 [[Prototype]] 属性都会被赋予一个非空的值。</p> <p>当你通过各种语法进行属性查找时都会查找 [[Prototype]] 链， 直到找到属性或者查找完整条原型链。</p> <p><code>属性设置和屏蔽</code> myObject.foo = &quot;bar&quot;;</p> <p>如果属性名 foo 既出现在 myObject 中也出现在 myObject 的 [[Prototype]] 链上层， 那么就会发生屏蔽。 myObject 中包含的 foo 属性会屏蔽原型链上层的所有 foo 属性， 因为myObject.foo 总是会选择原型链中最底层的 foo 属性。</p> <p><strong>5.2 “类”</strong></p> <p><code>类”函数</code></p> <p>多年以来， JavaScript 中有一种奇怪的行为一直在被无耻地滥用， 那就是模仿类。 我们会仔细分析这种方法。</p> <p>这种奇怪的“类似类” 的行为利用了函数的一种特殊特性： 所有的函数默认都会拥有一个名为 prototype 的公有并且不可枚举（参见第 3 章） 的属性， 它会指向另一个对象。</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">Foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token comment">// ...</span>
<span class="token punctuation">}</span>
<span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
Object<span class="token punctuation">.</span><span class="token function">getPrototypeOf</span><span class="token punctuation">(</span> a <span class="token punctuation">)</span> <span class="token operator">===</span> <span class="token class-name">Foo</span><span class="token punctuation">.</span>prototype<span class="token punctuation">;</span> <span class="token comment">// true</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>调用 new Foo() 时会创建 a（具体的 4 个步骤参见第 2 章）， 其中的一步就是给 a 一个内部的 [[Prototype]] 链接， 关联到 Foo.prototype 指向的那个对象。</p> <p>new Foo() 会生成一个新对象（我们称之为 a）， 这个新对象的内部链接 [[Prototype]] 关联的是 Foo.prototype 对象。最后我们得到了两个对象， 它们之间互相关联.</p> <p>这个机制通常被称为原型继承.</p> <p><strong>5.3 （原型） 继承</strong></p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">Foo</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
<span class="token punctuation">}</span> 
<span class="token class-name">Foo</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">myName</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">function</span> <span class="token function">Bar</span><span class="token punctuation">(</span><span class="token parameter">name<span class="token punctuation">,</span>label</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token function">Foo</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span> <span class="token keyword">this</span><span class="token punctuation">,</span> name <span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">this</span><span class="token punctuation">.</span>label <span class="token operator">=</span> label<span class="token punctuation">;</span>
<span class="token punctuation">}</span> <span class="token comment">// 我们创建了一个新的 Bar.prototype 对象并关联到 Foo.prototype</span>
<span class="token class-name">Bar</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span> <span class="token class-name">Foo</span><span class="token punctuation">.</span>prototype <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 注意！ 现在没有 Bar.prototype.constructor 了</span>
<span class="token comment">// 如果你需要这个属性的话可能需要手动修复一下它</span>
<span class="token class-name">Bar</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">myLabel</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>label<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Bar</span><span class="token punctuation">(</span> <span class="token string">&quot;a&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;obj a&quot;</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
a<span class="token punctuation">.</span><span class="token function">myName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// &quot;a&quot;</span>
a<span class="token punctuation">.</span><span class="token function">myLabel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// &quot;obj a&quot;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br></div></div><p><strong>5.4 对象关联</strong></p> <p>现在我们知道了， [[Prototype]] 机制就是存在于对象中的一个内部链接， 它会引用其他对象。</p> <p>通常来说， 这个链接的作用是： 如果在对象上没有找到需要的属性或者方法引用， 引擎就会继续在 [[Prototype]] 关联的对象上进行查找。 同理， 如果在后者中也没有找到需要的引用就会继续查找它的 [[Prototype]]， 以此类推。 这一系列对象的链接被称为“原型链”。</p> <p><strong>5.5 小结</strong></p> <p>如果要访问对象中并不存在的一个属性， [[Get]] 操作（参见第 3 章） 就会查找对象内部[[Prototype]] 关联的对象。 这个关联关系实际上定义了一条“原型链”（有点像嵌套的作用域链）， 在查找属性时会对它进行遍历。</p> <p>所有普通对象都有内置的 Object.prototype， 指向原型链的顶端（比如说全局作用域）， 如果在原型链中找不到指定的属性就会停止。 toString()、 valueOf() 和其他一些通用的功能都存在于 Object.prototype 对象上， 因此语言中所有的对象都可以使用它们。</p> <p>关联两个对象最常用的方法是使用 new 关键词进行函数调用， 在调用的 4 个步骤（ 第 2章） 中会创建一个关联其他对象的新对象。</p> <p>使用 new 调用函数时会把新对象的 .prototype 属性关联到“其他对象”。 带 new 的函数调用通常被称为“构造函数调用”， 尽管它们实际上和传统面向类语言中的类构造函数不一样。</p> <p>虽然这些 JavaScript 机制和传统面向类语言中的“类初始化” 和“类继承” 很相似， 但是 JavaScript 中的机制有一个核心区别， 那就是不会进行复制， 对象之间是通过内部的[[Prototype]] 链关联的。</p> <p>出于各种原因， 以“继承” 结尾的术语（包括“原型继承”） 和其他面向对象的术语都无法帮助你理解 JavaScript 的真实机制（不仅仅是限制我们的思维模式）。</p> <p>相比之下， “委托” 是一个更合适的术语， 因为对象之间的关系不是复制而是委托。</p> <h3 id="_6-行为委托"><a href="#_6-行为委托" class="header-anchor">#</a> 6.行为委托</h3> <p><strong>6.1 面向委托的设计</strong></p> <p><code>类理论</code>,<code>委托理论</code>,<code>比较思维模型</code>。</p> <p><strong>6.2 类与对象</strong></p> <p><code>控件“类”</code>,<code>委托控件对象</code>。</p> <p><strong>6.6 小结</strong></p> <p>在软件架构中你可以选择是否使用类和继承设计模式。 大多数开发者理所当然地认为类是唯一（合适） 的代码组织方式， 但是本章中我们看到了另一种更少见但是更强大的设计模
式： 行为委托。</p> <p>行为委托认为对象之间是兄弟关系， 互相委托， 而不是父类和子类的关系。 JavaScript 的[[Prototype]] 机制本质上就是行为委托机制。 也就是说， 我们可以选择在 JavaScript 中努力实现类机制（参见第 4 和第 5 章）， 也可以拥抱更自然的 [[Prototype]] 委托机制。</p> <p>当你只用对象来设计代码时， 不仅可以让语法更加简洁， 而且可以让代码结构更加清晰。</p> <p>对象关联（对象之前互相关联） 是一种编码风格， 它倡导的是直接创建和关联对象， 不把它们抽象成类。 对象关联可以用基于 [[Prototype]] 的行为委托非常自然地实现。</p></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><!----> <span class="next"><a href="/book/chapter-two.html">
        漫画算法 总结
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.a0896f0e.js" defer></script><script src="/assets/js/2.88eb2c00.js" defer></script><script src="/assets/js/35.f1909c5d.js" defer></script>
  </body>
</html>
